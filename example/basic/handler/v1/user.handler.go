// code generated by team142
package handler

import (
	"code-gen/example/basic"
	"code-gen/example/basic/presenter/v1"
	"database/sql"
	"github.com/gofiber/fiber/v2"
	"strconv"
	"strings"
)

/*
	{Backtick: TypeSpec:0xc0000082b8 Fields:[{Field:0xc000026380 Rules:[] Name:Id APIName:id VarName:id Type:int PrimaryKey:true} {Field:0xc0000263c0 Rules:[] Name:FirstName APIName:first_name VarName:firstName Type:string PrimaryKey:false} {Field:0xc000026400 Rules:[] Name:LastName APIName:last_name VarName:lastName Type:string PrimaryKey:false}] Ignored:false Version:V1 APIPath:/ PrimaryKeys:[{Field:0xc000026380 Rules:[] Name:Id APIName:id VarName:id Type:int PrimaryKey:true}] PrimaryKeyCount:1 Struct:{APIName:user Name:User VarName:user Package:basic PackageImportPath:code-gen/example/basic MiddlewareImportPath:code-gen/example/basic/middleware/v1 PresenterImportPath:code-gen/example/basic/presenter/v1 HandlerImportPath:code-gen/example/basic/handler/v1} Module:code-gen Package:handler IntermediaryPath:example/basic}
*/

/*
	We use the *sql.DB, although you can change this to *sql.TX if your process requires a transaction
	{ 0xc0000082b8 [{0xc000026380 [] Id id id int true} {0xc0000263c0 [] FirstName first_name firstName string false} {0xc000026400 [] LastName last_name lastName string false}] false V1 / [{0xc000026380 [] Id id id int true}] 1 {user User user basic code-gen/example/basic code-gen/example/basic/middleware/v1 code-gen/example/basic/presenter/v1 code-gen/example/basic/handler/v1} code-gen handler example/basic}
*/

// UserInterface is the core interface required for the functions to operate
// We use a separate struct interface, because we want to allow easy customisation and extension.
// You can easily refactor all the interfaces to be the same "StructInterface"
type UserInterface interface {
	// GetMultiple will get `basic.User` by the parameters passed in the request
	// Returning error, []Users, limit, nextId, total
	GetMultiple(db *sql.DB, params map[string]string) (error, []basic.User, int, int, int64)

	// Delete will delete `basic.User` by the data passed in the body
	Delete(db *sql.DB) error

	// Save will update or create `basic.User`
	// if override is passed, the update will update every field.
	// if the return bool is true, it means the User was created
	// if the return bool is false, it means the User was updated/overridden
	Save(db *sql.DB, override bool) (error, bool)

	// Validate will validate if the content is valid, returning nil if valid
	Validate() error
}

// UserPrimaryKeys is a struct which represents all the primary keys for basic.User
type UserPrimaryKeys struct {
	Id int `json:"id,omitempty"`
}

// GetMultipleUsers  get multiple `basic.User` filter by the query params
// @Summary          get multiple `basic.User` filter by the query params
// @Description      Get multiple users based on the query params
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          200  {object} presenter.DataArraySuccess{data=[]basic.User}
// @Success          204  {object} presenter.DataArraySuccess{data=[]basic.User}
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          500  {object} presenter.DataError{data=basic.User}
// @Router           /user [get]
// @Param            limit 			query      int     	false  "Limit" default(100)
// @Param            id 			query      int     	false  "Id"
// @Param            first_name 			query      string     	false  "FirstName"
// @Param            last_name 			query      string     	false  "LastName"
func GetMultipleUsers(db *sql.DB) fiber.Handler {
	return func(c *fiber.Ctx) error {
		var user UserInterface
		u := &basic.User{}
		user = u

		// STANDARD
		var err error
		var limit int
		var total int64

		// STRUCT SPECIFIC
		var users = make([]basic.User, 0, 0)
		var nextId int

		// We are going to get multiple users and the required fields for the response
		if err, users, limit, nextId, total = user.GetMultiple(
			db,
			c.AllParams(),
		); err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(
				presenter.DataError{
					Error: err,
				},
			)
		} else {
			first := basic.User{}
			if len(users) > 0 {
				first = users[0]
			} else {
				c.Status(fiber.StatusNoContent)
				return c.JSON(
					presenter.DataArraySuccess{
						Data:        users,
						Limit:       limit,
						ReturnValue: len(users),
						Total:       total,
					},
				)
			}
			c.Status(fiber.StatusOK)
			return c.JSON(
				presenter.DataArraySuccess{
					Data:        users,
					Limit:       limit,
					ReturnValue: len(users),
					From:        first.Id,
					Next:        nextId,
					Total:       total,
				},
			)
		}
	}
}

// GetUserById get a single `basic.User` by the `basic.User.Id`
// @Summary          This will get a single `basic.User` filtering using the `User.Id`
// @Description      Get a single User
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          200  {object} presenter.Data{data=basic.User}
// @Success          204  {object} presenter.DataError{data=string}
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          500  {object} presenter.DataError{data=basic.User}
// @Router           /user/{user} [get]
// @Param         	 user		path      int  true  "Id"
func GetUserById(db *sql.DB) fiber.Handler {
	return func(c *fiber.Ctx) error {
		var err error
		var user UserInterface
		u := &basic.User{}
		user = u

		var users []basic.User
		if err, users, _, _, _ = user.GetMultiple(
			db,
			map[string]string{"Id": c.Params("Id", "")},
		); err != nil {
			if strings.Contains(err.Error(), "not found") {
				c.Status(fiber.StatusNoContent)
				return c.JSON(
					presenter.DataError{
						Message: "not found",
						Data:    u,
						Error:   err,
					},
				)
			}

			c.Status(fiber.StatusInternalServerError)
			return c.JSON(
				presenter.DataError{
					Message: "error retrieving requested User",
					Data:    u,
					Error:   err,
				},
			)
		} else {
			if len(users) > 0 {
				c.Status(fiber.StatusAccepted)
				return c.JSON(
					presenter.DataSuccess{
						Data: users[0],
					},
				)
			} else {
				c.Status(fiber.StatusNoContent)
				return c.JSON(
					presenter.DataSuccess{},
				)
			}
		}
	}
}

// TraceUser trace a user request
// @Summary          Validate is the user sent in the body is accepted by the server
// @Description      Trace for User
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          202  {object} presenter.DataSuccess{data=basic.User}
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          406  {object} presenter.DataError{data=basic.User}
// @Router           /user [trace]
func TraceUser() fiber.Handler {
	return func(c *fiber.Ctx) error {
		var err error
		user := getUser(c)

		if err = user.Validate(); err != nil {
			c.Status(fiber.StatusNotAcceptable)
			return c.JSON(
				presenter.DataError{
					Message: err.Error(),
					Data:    user,
					Error:   err,
				},
			)
		}

		c.Status(fiber.StatusAccepted)
		return c.JSON(
			presenter.DataSuccess{
				Data: user,
			},
		)
	}
}

// SaveUser trace a user request
// @Summary          Save a user
// @Description      This will create a new User or replace/update a representation of the User with the request payload.
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          202  {object} presenter.DataSuccess{data=basic.User}
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          406  {object} presenter.DataError{data=basic.User}
// @Router           /user [put, post]
func SaveUser(db *sql.DB, override bool) fiber.Handler {
	return func(c *fiber.Ctx) error {
		var err error
		user := getUser(c)

		var created bool
		err, created = user.Save(db, override)
		if err != nil {
			c.Status(fiber.StatusNotAcceptable)
			return c.JSON(
				presenter.DataError{
					Message: "invalid data",
					Data:    user,
					Error:   err,
				},
			)
		}

		if created {
			c.Status(fiber.StatusCreated)
		} else {
			c.Status(fiber.StatusOK)
		}

		return c.JSON(
			presenter.DataSuccess{
				Data: user,
			},
		)
	}
}

// DeleteUser trace a user request
// @Summary          PUT a user
// @Description      This will delete User or replace a representation of the User with the request payload.
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          202  ""
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          406  {object} presenter.DataError{data=basic.User}
// @Router           /user [delete]
func DeleteUser(db *sql.DB) fiber.Handler {
	return func(c *fiber.Ctx) error {
		var err error
		user := getUser(c)

		err = user.Delete(db)
		if err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(
				presenter.DataError{
					Message: "internal database error",
					Data:    user,
					Error:   err,
				},
			)
		}

		c.Status(fiber.StatusOK)
		return c.Send(nil)
	}
}

// DeleteUserById deletes a user
// @Summary          DELETE a user
// @Description      This will delete User or replace a representation of the User with the request payload.
// @Tags             User
// @Accept           json,text/xml
// @Produce          json
// @Success          202  ""
// @Failure          400  {object} presenter.DataError{data=string}
// @Failure          401
// @Failure          403
// @Failure          406  {object} presenter.DataError{data=basic.User}
// @Router           /user/{user} [delete]
// @Param            user 			query      int     	false  "Id"
func DeleteUserById(db *sql.DB) fiber.Handler {
	return func(c *fiber.Ctx) error {
		var err error
		user := getUser(c)

		// This will only do this if the PK is an INT
		pk, errAtoi := strconv.Atoi(c.Params("Id", ""))
		if errAtoi != nil {
			c.Status(fiber.StatusBadRequest)
			return c.JSON(
				presenter.DataError{
					Message: "bad id",
					Error:   err,
				},
			)
		}

		//TODO: Need to set the structs primary keys

		err = user.Delete(db)
		if err != nil {
			c.Status(fiber.StatusInternalServerError)
			return c.JSON(
				presenter.DataError{
					Message: "internal database error",
					Data:    user,
					Error:   err,
				},
			)
		}

		c.Status(fiber.StatusOK)
		return c.Send(nil)
	}
}

// UserOptions
// @Summary          OPTIONS
// @Description      This will return an options for /user
// @Tags             User
// @Success          200  ""
// @Failure          401
// @Failure          403
// @Router           /user [options]
func UserOptions() fiber.Handler {
	return func(c *fiber.Ctx) error {
		c.Set("Allow", "OPTIONS, GET, POST, PUT, DELETE, TRACE")
		return c.Send(nil)
	}
}

func getUser(c *fiber.Ctx) UserInterface {
	userLocal := c.Locals("User")
	if userLocal == nil {
		return nil
	}
	return userLocal.(*basic.User)
}
